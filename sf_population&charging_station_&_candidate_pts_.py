# -*- coding: utf-8 -*-
"""SF population&charging station & candidate pts .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DevAIyXak2QQF_J0r57zC2WGqJWnRJ-I
"""

import pandas as pd
import matplotlib.pyplot as plt
import geopandas as gpd
import numpy as np
from google.colab import drive
from ortools.sat.python import cp_model

!pip install ortools

# Mount your Google Drive
drive.mount('/content/drive', force_remount=True)

# Paths to your files in Google Drive
# Update the paths based on the location of your files in Google Drive
census_path = '/content/drive/My Drive/240_Project/Census/ACSDT5Y2023.B01003-Data.csv'

df = pd.read_csv("/content/drive/My Drive/240_Project/Copy_alt_fuel_stations (Dec 12 2025)2.csv")

df_ca = df[df["State"] == "CA"]

df

# San Francisco bounding box
lon_min, lon_max = -122.52, -122.35
lat_min, lat_max = 37.70, 37.83

df_sf = df_ca[
    (df_ca["Longitude"] >= lon_min) &
    (df_ca["Longitude"] <= lon_max) &
    (df_ca["Latitude"]  >= lat_min) &
    (df_ca["Latitude"]  <= lat_max)
]

pop_csv = "/content/drive/My Drive/240_Project/Census/ACSDT5Y2023.B01003-Data.csv"
pop = pd.read_csv(pop_csv, dtype={"GEO_ID": str, "GEOID": str})

if "GEOID" not in pop.columns and "GEO_ID" in pop.columns:
    pop["GEOID"] = pop["GEO_ID"].str[-11:]

pop_sf = pop[pop["GEOID"].str.startswith("06075")].copy()

pop_col = "B01003_001E"
if pop_col not in pop_sf.columns:
    raise ValueError(f"Population column {pop_col} not found in population CSV")

tract_shp = "/content/drive/My Drive/240_Project/Census/tl_2023_06_tract/tl_2023_06_tract.shp"
tracts = gpd.read_file(tract_shp)

tracts_sf = tracts[(tracts["STATEFP"] == "06") & (tracts["COUNTYFP"] == "075")].copy()

tracts_sf = tracts_sf.to_crs(epsg=3857)
tracts_sf["centroid"] = tracts_sf.geometry.centroid
tracts_sf = tracts_sf.set_geometry("centroid").to_crs(epsg=4326)

tracts_sf["lon"] = tracts_sf.geometry.x
tracts_sf["lat"] = tracts_sf.geometry.y

demand = tracts_sf[["GEOID", "lon", "lat"]].merge(
    pop_sf[["GEOID", pop_col]],
    on="GEOID",
    how="inner"
)

plt.figure(figsize=(7, 7))

plt.scatter(df_sf["Longitude"], df_sf["Latitude"], s=10, alpha=0.8, label="Existing charging stations")

sizes = (demand[pop_col].astype(float) * 0.002).clip(5, 80)
plt.scatter(demand["lon"], demand["lat"], s=sizes, alpha=0.4, label="Demand points (tract centroids)")

plt.plot([lon_min, lon_max, lon_max, lon_min, lon_min],
         [lat_min, lat_min, lat_max, lat_max, lat_min],
         linewidth=2)
plt.xlim(-122.52, -122.35)
plt.ylim(37.70, 37.83)
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("SF Charging Stations + Demand Points (Census Tract Centroids)")
plt.legend()
plt.show()

print("SF stations plotted:", len(df_sf))
print("SF demand points plotted:", len(demand))

def haversine_km(lon1, lat1, lon2, lat2):
    """
    lon1, lat1: scalars or arrays
    lon2, lat2: scalars or arrays
    returns: distances in km with broadcasting
    """
    R = 6371.0
    lon1 = np.radians(lon1)
    lat1 = np.radians(lat1)
    lon2 = np.radians(lon2)
    lat2 = np.radians(lat2)

    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = np.sin(dlat / 2.0) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2.0) ** 2
    return 2.0 * R * np.arcsin(np.sqrt(a))

def build_candidates_scheme_A(E_df, P_df, R_km=5.0, lon_col="lon", lat_col="lat"):
    """
    Returns:
      C_df: candidates (subset of P_df) that are NOT covered by any existing station within R_km
      covered_mask: boolean array for P_df indicating covered by existing
    """
    # demand arrays
    P_lon = P_df[lon_col].to_numpy(dtype=float)
    P_lat = P_df[lat_col].to_numpy(dtype=float)

    # existing arrays
    E_lon = E_df[lon_col].to_numpy(dtype=float)
    E_lat = E_df[lat_col].to_numpy(dtype=float)

    covered = np.zeros(len(P_df), dtype=bool)

    # For each existing station, mark demand points within R_km
    # (Loop over stations is fine: 532*244 is tiny)
    for i in range(len(E_df)):
        d = haversine_km(E_lon[i], E_lat[i], P_lon, P_lat)
        covered |= (d <= R_km)

    # Candidates = uncovered demand points
    C_df = P_df.loc[~covered].copy()

    return C_df, covered

E_df = df_sf.rename(columns={"Longitude":"lon", "Latitude":"lat"})
P_df = demand.rename(columns={"lon":"lon", "lat":"lat"})
R_km=1.0

C_df, covered_mask = build_candidates_scheme_A(E_df, P_df, R_km=R_km, lon_col="lon", lat_col="lat")

print("R (km):", R_km)
print("Demand points |P|:", len(P_df))
print("Covered by existing:", covered_mask.sum())
print("Uncovered => candidates |C|:", len(C_df))

lon_min, lon_max = -122.52, -122.35
lat_min, lat_max = 37.70, 37.83

plt.figure(figsize=(7, 7))

# Demand points
plt.scatter(P_df["lon"], P_df["lat"], s=15, alpha=0.25, label="Demand points (tract centroids)")

# Existing stations
plt.scatter(E_df["lon"], E_df["lat"], s=10, alpha=0.8, label="Existing stations")

# Candidate points Cï¼ˆ
plt.scatter(C_df["lon"], C_df["lat"], s=60, marker="x", linewidths=2, label="Candidates C (uncovered demand)")

plt.xlim(lon_min, lon_max)
plt.ylim(lat_min, lat_max)
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("Existing Stations + Demand Points + Candidates C")
plt.legend()
plt.show()

k = 5
C_df = C_df.reset_index(drop=True)

def build_coverage_matrix(P_df, C_df, R_km, lon_col="lon", lat_col="lat"):
    P_lon = P_df[lon_col].to_numpy(float)
    P_lat = P_df[lat_col].to_numpy(float)
    C_lon = C_df[lon_col].to_numpy(float)
    C_lat = C_df[lat_col].to_numpy(float)

    A = np.zeros((len(P_df), len(C_df)), dtype=np.uint8)

    for j in range(len(C_df)):
        d = haversine_km(C_lon[j], C_lat[j], P_lon, P_lat)
        A[:, j] = (d <= R_km).astype(np.uint8)

    return A

A = build_coverage_matrix(P_df, C_df, R_km=R_km)
print("Coverage matrix shape:", A.shape)
print("Avg cover per candidate:", A.sum(axis=0).mean())

def solve_max_coverage_ilp_aligned(A, k, weights, existing_covered_mask=None, time_limit_s=30):
    nP, nC = A.shape
    A = A.astype(np.uint8)

    existing = np.zeros(nP, dtype=bool) if existing_covered_mask is None else np.array(existing_covered_mask, dtype=bool).copy()

    w = np.array(weights, dtype=float)
    w_eff = w.copy()
    w_eff[existing] = 0.0
    w_eff = w_eff.astype(int)  # CP-SAT needs int

    model = cp_model.CpModel()
    x = [model.NewBoolVar(f"x[{j}]") for j in range(nC)]
    y = [model.NewBoolVar(f"y[{i}]") for i in range(nP)]

    model.Add(sum(x) <= int(k))

    for i in range(nP):
        coverers = [j for j in range(nC) if A[i, j] == 1]
        if not coverers:
            model.Add(y[i] == 0)
            continue

        # y <= sum(coverers)
        model.Add(y[i] <= sum(x[j] for j in coverers))
        # x[j] -> y[i]
        for j in coverers:
            model.AddImplication(x[j], y[i])

    model.Maximize(sum(int(w_eff[i]) * y[i] for i in range(nP)))

    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = float(time_limit_s)
    solver.parameters.num_search_workers = 8

    status = solver.Solve(model)
    if status not in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        return None

    x_sol = np.array([solver.Value(v) for v in x], dtype=int)
    selected = np.where(x_sol == 1)[0].tolist()

    if len(selected) == 0:
        sel_cov = np.zeros(nP, dtype=bool)
    else:
        sel_cov = (A[:, selected].sum(axis=1) > 0)

    final_cov = existing | sel_cov
    added_cov = sel_cov & (~existing)

    return {
        "status": status,
        "selected_indices": selected,
        "existing_covered_mask": existing,
        "final_covered_mask": final_cov,
        "added_covered_mask": added_cov,
        "existing_covered_weight": float(w[existing].sum()),
        "added_covered_weight": float(w[added_cov].sum()),
        "final_covered_weight": float(w[final_cov].sum()),
        "final_covered_count": int(final_cov.sum()),
        "added_covered_count": int(added_cov.sum()),
        "objective_added_only": float(solver.ObjectiveValue()),
    }

weights = P_df["B01003_001E"].fillna(0).astype(int).to_numpy()

res_ilp = solve_max_coverage_ilp_aligned(
    A,
    k=k,
    weights=weights,
    time_limit_s=30,
    existing_covered_mask=covered_mask
)
print("ILP results")
print("Selected facilities:", len(res_ilp["selected_indices"]))
print("Existing covered population:", res_ilp["existing_covered_weight"])
print("Added covered population:", res_ilp["added_covered_weight"])
print("Final covered population:", res_ilp["final_covered_weight"])
print("Final covered demand points:", res_ilp["final_covered_count"])
print("Added covered demand points:", res_ilp["added_covered_count"])
ilp_selected = res_ilp["selected_indices"]
C_ilp = C_df.iloc[ilp_selected].copy()
C_ilp["selected"] = 1
print("ILP selected facilities:", len(ilp_selected))
display(C_ilp[["GEOID", "lon", "lat"] + (["B01003_001E"] if "B01003_001E" in C_ilp.columns else []) + ["selected"]])

def greedy_select_max_coverage_from_A(
    A, P_df, k,
    weight_col=None,
    existing_covered_mask=None
):
    nP, nC = A.shape
    A_bool = A.astype(bool)  # safe

    # weights
    if weight_col is None:
        w = np.ones(nP, dtype=float)
    else:
        w = P_df[weight_col].fillna(0).to_numpy(dtype=float)

    # existing covered baseline
    if existing_covered_mask is None:
        existing = np.zeros(nP, dtype=bool)
    else:
        existing = np.array(existing_covered_mask, dtype=bool).copy()

    covered = existing.copy()
    selected = []
    available = np.ones(nC, dtype=bool)

    for _ in range(int(k)):
        uncovered = ~covered

        best_j = None
        best_gain = 0.0

        for j in np.where(available)[0]:
            new_cov = A_bool[:, j] & uncovered
            gain = float(w[new_cov].sum())
            if gain > best_gain:
                best_gain = gain
                best_j = int(j)

        if best_j is None or best_gain <= 0:
            break

        selected.append(best_j)
        covered |= A_bool[:, best_j]
        available[best_j] = False

    added = covered & (~existing)

    return {
        "selected_indices": selected,
        "existing_covered_mask": existing,
        "final_covered_mask": covered,
        "added_covered_mask": added,
        "existing_covered_weight": float(w[existing].sum()),
        "added_covered_weight": float(w[added].sum()),
        "final_covered_weight": float(w[covered].sum()),
        "existing_covered_count": int(existing.sum()),
        "added_covered_count": int(added.sum()),
        "final_covered_count": int(covered.sum()),
    }

A = build_coverage_matrix(P_df, C_df, R_km=R_km)

res_greedy = greedy_select_max_coverage_from_A(
    A=A,
    P_df=P_df,
    k=k,
    weight_col="B01003_001E",
    existing_covered_mask=covered_mask
)

greedy_selected = res_greedy["selected_indices"]
C_greedy = C_df.iloc[greedy_selected].copy()
C_greedy["selected"] = 1

print("=== Greedy results ===")
print("Selected facilities:", len(greedy_selected))
print("Existing covered population:", res_greedy["existing_covered_weight"])
print("Added covered population:", res_greedy["added_covered_weight"])
print("Final covered population:", res_greedy["final_covered_weight"])
print("Final covered demand points:", res_greedy["final_covered_count"])
print("Added covered demand points:", res_greedy["added_covered_count"])

C_greedy.head()

k_list = list(range(1, 66))
results = []

for k in k_list:
    # ----- Greedy -----
    res_g = greedy_select_max_coverage_from_A(
        A=A,
        P_df=P_df,
        k=k,
        weight_col="B01003_001E",
        existing_covered_mask=covered_mask
    )

    # ----- ILP -----
    res_i = solve_max_coverage_ilp_aligned(
        A=A,
        k=k,
        weights=weights.astype(int),
        existing_covered_mask=covered_mask,
        time_limit_s=30
    )

    results.append({
        "k": k,
        "method": "Greedy",
        "added_pop": res_g["added_covered_weight"],
        "added_pts": res_g["added_covered_count"]
    })
    results.append({
        "k": k,
        "method": "ILP",
        "added_pop": res_i["added_covered_weight"],
        "added_pts": res_i["added_covered_count"]
    })

df_res = pd.DataFrame(results)
plt.figure(figsize=(7,5))
for m in ["Greedy", "ILP"]:
    sub = df_res[df_res["method"] == m]
    plt.plot(sub["k"], sub["added_pop"], marker="o", label=m)

plt.xlabel("Number of new facilities (k)")
plt.ylabel("Added covered population")
plt.title("Greedy vs ILP: Added Population Coverage")
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(7,5))
for m in ["Greedy", "ILP"]:
    sub = df_res[df_res["method"] == m]
    plt.plot(sub["k"], sub["added_pts"], marker="o", label=m)

plt.xlabel("Number of new facilities (k)")
plt.ylabel("Added covered demand points")
plt.title("Greedy vs ILP: Added Demand Points")
plt.legend()
plt.grid(True)
plt.show()